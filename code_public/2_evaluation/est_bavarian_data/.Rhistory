breaks = seq(max(plot_nc_2$data$date),
lubridate::ymd("2020-04-30"),
"-1 month"),
date_labels = "%d.%m.%y") +
coord_cartesian(xlim = c(lubridate::ymd("2020-05-01"), now)) +
scale_y_continuous(limits = c(0, max(plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$reported_new_cases)))
plot_nc_2
max(plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$reported_new_cases)
plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]
plot_nc_2 = plot_nc_2 +
scale_x_date(limits = c(lubridate::ymd("2020-04-30"), now),
breaks = seq(max(plot_nc_2$data$date),
lubridate::ymd("2020-04-30"),
"-1 month"),
date_labels = "%d.%m.%y") +
coord_cartesian(xlim = c(lubridate::ymd("2020-05-01"), now)) +
scale_y_continuous(limits = c(0, max(c(plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$reported_new_cases,
plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$q975)))
}
}
else {
now <- max(nowcast_tb_muc$date) + 2
plot_nc_2 = gg_list_muc[[2]] +
geom_point(aes(x=now, y=0), colour = "gold", shape = 14, size = 1.5, show.legend = FALSE) +
scale_x_date(breaks = seq(max(gg_list_muc[[2]]$data$date),
min(gg_list_muc[[2]]$data$date),
"-1 month"),
date_labels = "%d.%m.%y")
if(input$select_nc_may) {
plot_nc_2 = plot_nc_2 + scale_x_date(limits = c(lubridate::ymd("2020-04-30"), now),
breaks = seq(max(plot_nc_2$data$date),
lubridate::ymd("2020-04-30"),
"-1 month"),
date_labels = "%d.%m.%y") +
coord_cartesian(xlim = c(lubridate::ymd("2020-05-01"), now)) +
scale_y_continuous(limits = c(0, max(plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$reported_new_cases)))
}
}
plot_nc_2 + theme(axis.text=element_text(size=14), axis.title = element_text(size=14))
})
plot_nc_2 = plot_nc_2 +
scale_x_date(limits = c(lubridate::ymd("2020-04-30"), now),
breaks = seq(max(plot_nc_2$data$date),
lubridate::ymd("2020-04-30"),
"-1 month"),
date_labels = "%d.%m.%y") +
coord_cartesian(xlim = c(lubridate::ymd("2020-05-01"), now)) +
scale_y_continuous(limits = c(0, max(c(plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$reported_new_cases,
plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$q975))))
plot_nc_2
now <- max(nowcast_tb$date) + 2
plot_nc_2 = gg_list[[2]] +
geom_point(aes(x=now, y=0), colour = "gold", shape = 14, size = 1.5, show.legend = FALSE) +
scale_x_date(breaks = seq(max(gg_list[[2]]$data$date),
min(gg_list[[2]]$data$date),
"-1 month"),
date_labels = "%d.%m.%y")
if(input$select_nc_may) {
plot_nc_2 = plot_nc_2 +
scale_x_date(limits = c(lubridate::ymd("2020-04-30"), now),
breaks = seq(max(plot_nc_2$data$date),
lubridate::ymd("2020-04-30"),
"-1 month"),
date_labels = "%d.%m.%y") +
coord_cartesian(xlim = c(lubridate::ymd("2020-05-01"), now)) +
scale_y_continuous(limits = c(0, max(c(plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$reported_new_cases,
plot_nc_2$data[plot_nc_2$data$date>=ymd("2020-05-01"),]$q975))))
}
plot_nc_2
runApp()
setwd("~/Documents/nowcast_server/code")
## Functions to perform the steps can be found in 99_daily_analysis_fun.R
source("./daily_analysis_fun_stanmodel_2.R")
# Load required packages
library(tidyverse)
library(data.table)
library(surveillance)
library(broom)
library(readr)
library(lubridate)
library(knitr)
library(rstan)
library(nleqslv)
set.seed(523523)
data_filepath = "../data/2020_10_12_8Uhr_IfSG_Daten.csv"
data_date = ymd("2020-10-12")
if (!dir.exists(paste0("../report/", data_date,"/"))) {
dir.create(paste0("../report/", data_date,"/"))
}
## Read edit data:
## In: filepath
## Out: dat_edit
dat_edit = read_edit_data(data_filepath, data_date)
dat_summary = summarize_data(dat_edit)
reported_cases_per_day = dat_edit %>% group_by(rep_date_reg) %>% summarise(n_rep = n())
day_seq = tibble(rep_date_reg= seq(min(dat_edit$rep_date_reg), data_date, 1))
reported_cases_per_day = right_join(reported_cases_per_day, day_seq, by = "rep_date_reg") %>%
mutate(n_rep = replace_na(n_rep, 0))
View(reported_cases_per_day)
runApp('~/Documents/nowcast_covid19_website/shiny_app_nowcast')
shiny::runApp()
runApp()
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation")
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation")
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9
bav_files = c("../../results_public/2_evaluation/bavaria/poiss_rW_const.RData",
"../../results_public/2_evaluation/bavaria/poiss_rW_cp_2w.RData",
"../../results_public/2_evaluation/bavaria/negBinom_rW_rW.RData",
"../../results_public/2_evaluation/bavaria/negBinom_rW_rW_wd.RData",
"../../results_public/2_evaluation/bavaria/negBinom_rW_cp_2w.RData",
"../../results_public/2_evaluation/bavaria/negBinom_rW_cp_2w_wd.RData")
# True data summary
dat_bav_smry = read_tsv("../../data_public/evaluation/dat_bavaria_truth_epcurve_reported.csv")
ntInf = do.call(rbind, lapply(bav_files,
function(x) {
load(file = x)
do.call(rbind, lapply(res_list, function(x) x$ntInf))
}))
ntInf = ntInf %>% mutate(lag = as.numeric(now-date),
model = factor(model, levels = c("poisson_rW_const",
"poisson_rW_cp2W",
"negBinom_rW_cp2W",
"negBinom_rW_rW",
"negBinom_rW_cp2W_wd",
"negBinom_rW_rW_wd")))
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9, fig.cap="Daily numbers of newly diseased cases and reported cases in Bavarian data. Numbers of disease onsets are derived retrospectively based on data available on July, 31."
ggplot(dat_bav_smry) + geom_line(aes(date, n_dis), col = "green") +
geom_line(aes(date, n_rep), col = "red", lty = 2) +
theme_bw() + ylab("No. cases")
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9, fig.cap="Empirical reporting delay distribution (between disease onset and reporting at LGL) for the Bavarian COVID-19 data."
delay_true_smry = read_tsv("../../data_public/evaluation/dat_bavaria_truth_delay_smry.csv")
delay_true_smry %>%
ggplot() + geom_line(aes(date, med_delay), col = "green") +
geom_ribbon(aes(date, ymin = q25_delay, ymax = q75_delay), alpha=.25, fill="green") +
coord_cartesian(xlim=c(ymd("2020-03-15"), ymd("2020-07-01"))) +
theme_bw() + ylab("Reporting delay")
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9
cov_full = left_join(ntInf, dat_bav_smry) %>%
mutate(coverage = q025<=n_dis & n_dis <= q975) %>%
filter(lag %in% 2:6) %>%
group_by(model) %>% summarise(frac_cov = mean(coverage))
cov_may = left_join(ntInf, dat_bav_smry) %>%
mutate(coverage = q025<=n_dis & n_dis <= q975) %>%
filter(lag %in% 2:6, date <ymd("2020-05-01")) %>%
group_by(model) %>% summarise(frac_cov = mean(coverage))
# Summarise Scoring Rules
crps_full = ntInf %>% filter(lag %in% c(2:6)) %>% group_by(model) %>% summarise(crps = mean(crps_score))
crps_may = ntInf %>% filter(lag %in% c(2:6),
date < ymd("2020-05-01")) %>% group_by(model) %>% summarise(crps = mean(crps_score))
logsc_full = ntInf %>% filter(lag %in% c(2:6)) %>% group_by(model) %>% summarise(logS = mean(log_score))
logsc_may = ntInf %>% filter(lag %in% c(2:6),
date < ymd("2020-05-01")) %>% group_by(model) %>% summarise(logS = mean(log_score))
rmse_full = ntInf %>% filter(lag %in% c(2:6)) %>%
left_join(dat_bav_smry)) %>%
mutate(diff = med - n_dis) %>%
group_by(model) %>% summarise(rmse = sqrt(mean(diff^2)))
ntInf
ntInf %>% filter(lag %in% c(2:6)) %>%
left_join(dat_bav_smry)
ntInf %>% filter(lag %in% c(2:6)) %>%
left_join(dat_bav_smry) %>%
mutate(diff = med - n_dis) %>%
group_by(model) %>% summarise(rmse = sqrt(mean(diff^2)))
rmse_full = ntInf %>% filter(lag %in% c(2:6)) %>%
left_join(dat_bav_smry) %>%
mutate(diff = med - n_dis) %>%
group_by(model) %>% summarise(rmse = sqrt(mean(diff^2)))
rmse_may = ntInf %>% filter(lag %in% c(2:6),
date < ymd("2020-05-01")) %>%
left_join(dat_bav_smry) %>%
mutate(diff = med - n_dis) %>%
group_by(model) %>% summarise(rmse = sqrt(mean(diff^2)))
load("../../data_public/evaluation/dat_bavaria_true_Rt.RData")
Rt = do.call(rbind, lapply(bav_files,
function(x) {
load(file = x)
do.call(rbind, lapply(res_list, function(x) x$Rt))
}))
Rt = Rt %>% mutate(lag=now-Date,
model = factor(model, levels = c("poisson_rW_const",
"poisson_rW_cp2W",
"negBinom_rW_cp2W",
"negBinom_rW_rW",
"negBinom_rW_cp2W_wd",
"negBinom_rW_rW_wd"))) %>%
left_join(true_Rt %>% rename(Date=date,
Rt_true=Rt))
cov_Rt = Rt %>% filter(lag==11) %>% mutate(cov_95 = Rt_lower<=Rt_true & Rt_upper>=Rt_true) %>%
group_by(model) %>% summarise(frac_cov_95 = mean(cov_95))
smry_bav_paper = tibble(
DistrNtd = c("Poisson", "Poisson", rep("Neg. Binomial", 4)),
DelayMod = c("No changes", "Lin. effect of time changepoints 2 weeks", "Lin. effect of time changepoints 2 weeks",
"Daily changes (first order RW)",
"Lin. effect of time changepoints 2 weeks + weekday effect",
"Daily changes (first order RW) + weekday effect"),
CRPS = crps_full$crps,
logS = logsc_full$logS,
RMSE = rmse_full$rmse,
CovNtInf = cov_full$frac_cov,
CovRt = round(cov_Rt$frac_cov_95,2))
kable(tibble(model = crps_full$model, crps_f = crps_full$crps, crps_m = crps_may$crps,
logS_f = logsc_full$logS, logS_m = logsc_may$logS,
rmse_f = rmse_full$rmse, rmse_m = rmse_may$rmse,
cov_f = cov_full$frac_cov, cov_m = cov_may$frac_cov,
cov_Rt = cov_Rt$frac_cov_95), digits = 2, caption="Retrospective quantification of the performance of six different nowcast models on Bavarian COVID-19 data. Shown are the average metrics over all nowcast dates (*_f) and restricted to the period until May, 1 (*_m). Reported scores are the continuous ranked probability score, logarithmic score, root mean squared error of posterior median, and coverage frequencies of 95% prediction intervals, as well as coverage frequencies of the estimated R(t) at the most current date. Estimated models are Poisson and Negative Binomial models with 1) (assumed) constant delay distribution, 2) linear time-effects with changepoints every two weeks before now (*_cp2W), 3) daily changes in delay distribution based on a first-order random walk prior (*_rW) and 2) and 3) with additional effects of the weekday of case reporting (*_wd).")
tibble(model = crps_full$model, crps_f = crps_full$crps, crps_m = crps_may$crps,
logS_f = logsc_full$logS, logS_m = logsc_may$logS,
rmse_f = rmse_full$rmse, rmse_m = rmse_may$rmse,
cov_f = cov_full$frac_cov, cov_m = cov_may$frac_cov,
cov_Rt = cov_Rt$frac_cov_95)
tibble(model = crps_full$model, crps_f = crps_full$crps, crps_m = crps_may$crps,
logS_f = logsc_full$logS, logS_m = logsc_may$logS,
rmse_f = rmse_full$rmse, rmse_m = rmse_may$rmse,
cov_f = cov_full$frac_cov, cov_m = cov_may$frac_cov,
cov_Rt = cov_Rt$frac_cov_95)$rmse_f
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9, fig.cap="Estimated R(t) over time based on all nowcast models at most current date and associated 95% CI. Comparison with R(t) based on all reported disease onsets until July, 31."
Rt %>% filter(lag == 11) %>% ggplot() +
geom_line(aes(Date, Rt, col = model)) +
geom_ribbon(aes(Date, ymin = Rt_lower, ymax = Rt_upper, fill = model), alpha = .1) +
geom_line(aes(Date, Rt_true), lty = 2, lwd = 1.2) +
theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom")
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9, fig.cap="Estimated R(t) over time based on all nowcast models at most current date and associated 95% CI. Comparison with R(t) based on all reported disease onsets until July, 31."
Rt %>% filter(lag == 1) %>% ggplot() +
geom_line(aes(Date, Rt, col = model)) +
geom_ribbon(aes(Date, ymin = Rt_lower, ymax = Rt_upper, fill = model), alpha = .1) +
geom_line(aes(Date, Rt_true), lty = 2, lwd = 1.2) +
theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom")
Rt
#+ message=FALSE, warning=FALSE, echo=FALSE, fig.height = 3.5, fig.width = 9, fig.cap="Estimated R(t) over time based on all nowcast models at most current date and associated 95% CI. Comparison with R(t) based on all reported disease onsets until July, 31."
Rt %>% filter(lag == 11) %>% ggplot() +
geom_line(aes(Date, Rt, col = model)) +
geom_ribbon(aes(Date, ymin = Rt_lower, ymax = Rt_upper, fill = model), alpha = .1) +
geom_line(aes(Date, Rt_true), lty = 2, lwd = 1.2) +
theme_bw() + theme(legend.title = element_blank(), legend.position = "bottom")
setwd("~/Documents/lrzhome/nowcast/evaluation_paper/bavaria/code_misc")
source("~/LRZ Sync+Share/nowcast/code/daily_analysis_fun_stanmodel.R")
library(data.table)
library(tidyverse)
library(lubridate)
library(surveillance)
dat = read_edit_data("~/LRZ Sync+Share/nowcast/data/2020_08_03_9Uhr_IfSG_Daten.csv", data_date = ymd("2020-08-03"))
dat = dat %>% filter(!is.na(disease_start),
disease_start<=rep_date_reg,
rep_date_reg-disease_start<40)
dat_mod = dat %>%
dplyr::select(rep_date = rep_date_reg,
rep_date_weekday = rep_date_reg_weekday,
disease_start) %>% filter(rep_date<ymd("2020-08-01"))
source("~/LRZ Sync+Share/nowcast/code/daily_analysis_fun_stanmodel.R")
library(data.table)
library(tidyverse)
library(lubridate)
library(surveillance)
dat = read_edit_data("~/LRZ Sync+Share/nowcast/data/2020_08_03_9Uhr_IfSG_Daten.csv", data_date = ymd("2020-08-03"))
dat = dat %>% filter(!is.na(disease_start),
disease_start<=rep_date_reg,
rep_date_reg-disease_start<40)
dat_mod = dat %>%
dplyr::select(rep_date = rep_date_reg,
rep_date_weekday = rep_date_reg_weekday,
disease_start) %>% filter(rep_date<ymd("2020-08-01"))
dat_mod
table(dat_mod$rep_date>=dat_mod$disease_start
)
set.seed(124)
dat_mod_synth = dat_mod %>%
mutate(disease_start = pmin(disease_start-rnorm(n(), 0,2), rep_date))
plot(dat_mod$rep_date, dat_mod$disease_start)
plot(dat_mod_synth$rep_date, dat_mod_synth$disease_start)
table(dat_mod_synth$rep_date>=dat_mod_synth$disease_start)
save(dat_mod_synth, file = "~/Documents/nc_covid19_bavaria/data_public/evaluation/dat_bavaria_persspec_synth.RData")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_bavarian_data")
# load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
source("../simulation_fun.R")
source("../simulation_fun.R")
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
eval_dates = eval_dates[1]
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
cat(libs_cmd)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
res_list
load("../../../data_public/evaluation/dat_mod_synthetic.RData")
rm(dat_mod)
dat_mod = dat_mod_synth
save(dat_mod, file = "~/Documents/nc_covid19_bavaria/data_public/evaluation/dat_bavaria_persspec_synth.RData")
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_bavarian_data")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
source("../simulation_fun.R")
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
eval_dates = eval_dates[1]
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
save(res_list, file = paste0(project_path, "nowcast/evaluation_paper/bavaria/6_negBinom_rW_cp_2w/res_list_1.RData"))
res_list
load("../../../results_public/2_evaluation/bavaria/negBinom_rW_cp_2w.RData")
summary8res_list
summary(res_list)
unique(res_list[[1]]$ntInf$now
)
lapply(res_list, function(x) unique(x[[1]]$ntInf$now))
unique(res_list[[1]][[1]]$ntInf$now)
lapply(res_list, function(x) unique(x$ntInf$now))
res_list[[11]]
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("./simulation_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
# eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("./simulation_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
# eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data availabl until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Apply over dates to perform nowcasting based on data availabl until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
res_list
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_bavarian_data")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("./simulation_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data availabl until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
# save(res_list, file = "../../../results_public/2_evaluation/bavaria/negBinom_rW_cp_2w_synthetic.RData")
dat_mod %>% filter(rep_date<=eval_dates)
res_list
load("~/Documents/lrzhome/nowcast/evaluation_paper/bavaria/dat_mod.RData")
dat_mod %>% filter(rep_date<=eval_dates)
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data availabl until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
res_list
source("../simulation_fun.R")
# Apply over dates to perform nowcasting based on data availabl until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
res_list
