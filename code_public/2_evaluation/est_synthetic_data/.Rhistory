0.00.*46000
0.003*46000
0.003*1850
109/46461
109/46461*1850
109/1339
16/25
shiny::runApp('~/Documents/nowcast_covid19_website/shiny_app_nowcast')
1/0.54
1/0.59
setwd("~/Documents/lrzhome/nowcast/evaluation_paper/bavaria/code_misc")
load("../dat_mod.RData")
source("~/LRZ Sync+Share/nowcast/code/daily_analysis_fun_stanmodel.R")
library(data.table)
library(tidyverse)
library(lubridate)
library(surveillance)
dat = read_edit_data("~/LRZ Sync+Share/nowcast/data/2020_08_03_9Uhr_IfSG_Daten.csv", data_date = ymd("2020-08-03"))
dat = dat %>% filter(!is.na(disease_start),
disease_start<=rep_date_reg,
rep_date_reg-disease_start<40)
dat_mod = dat %>%
dplyr::select(rep_date = rep_date_reg,
rep_date_weekday = rep_date_reg_weekday,
disease_start) %>% filter(rep_date<ymd("2020-08-01"))
set.seed(124)
-2:2
colnames(dat_mod)
pmax(ymd("2020-04-01", "2020-04-02")+1, ymd("2020-04-03", "2020-04-02"))
pmin(ymd("2020-04-01", "2020-04-02")+1, ymd("2020-04-03", "2020-04-02"))
set.seed(124)
dat_mod_synth = dat_mod %>%
mutate(rep_diff = sample(-2:2, size=n(), replace = T, prob = c(.1,.2,.4,.2,.1))) %>%
mutate(rep_date = rep_date + rep_diff,
disease_start = rep_date + rep_diff) %>%
mutate(disease_start = pmin(disease_start + sample(-1:1, n(), replace = T), rep_date))
plot(dat_mod_synth$rep_date, dat_mod$rep_date)
summary(dat_mod_synth$rep_date - dat_mod$rep_date)
summary(as.numeric(dat_mod_synth$rep_date - dat_mod$rep_date))
summary(as.numeric(dat_mod_synth$disease_start - dat_mod$disease_start))
set.seed(124)
dat_mod_synth = dat_mod %>%
mutate(rep_diff = sample(-2:2, size=n(), replace = T, prob = c(.1,.2,.4,.2,.1))) %>%
mutate(rep_date = rep_date + rep_diff,
disease_start = disease_start + rep_diff) %>%
mutate(disease_start = pmin(disease_start + sample(-1:1, n(), replace = T), rep_date))
summary(as.numeric(dat_mod_synth$rep_date - dat_mod$rep_date))
summary(as.numeric(dat_mod_synth$disease_start - dat_mod$disease_start))
plot(dat_mod$rep_date, dat_mod$disease_start)
plot(dat_mod_synth$rep_date, dat_mod_synth$disease_start)
# plot(dat_mod$rep_date, dat_mod$disease_start)
# plot(dat_mod_synth$rep_date, dat_mod_synth$disease_start)
dat_mod = dat_mod_synth
# plot(dat_mod$rep_date, dat_mod$disease_start)
# plot(dat_mod_synth$rep_date, dat_mod_synth$disease_start)
# dat_mod = dat_mod_synth
save(dat_mod, file = "~/Documents/nc_covid19_bavaria/data_public/evaluation/dat_bavaria_persspec_synth.RData")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("./simulation_fun.R")
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_bavarian_data")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("./simulation_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Load functions to estimate nowcast
source("../simulation_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data availabl until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W"),
error = function(e) e)
})
res_list
eval_dates
save(res_list, file = "../../../results_public/2_evaluation/bavaria/negBinom_rW_cp_2w_synthetic.RData")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../../models/poisson_rWalk_cp.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "poisson_rW_cp2W"),
error = function(e) e)
})
res_list
# Load model
mod = readRDS("../stan_models/poisson_rWalk_cp.rds")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/poisson_rWalk_cp.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "poisson_rW_cp2W"),
error = function(e) e)
})
res_list
save(res_list, file = "../../../results_public/2_evaluation/bavaria/poiss_rW_const_synthetic.RData")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/poisson_rWalk_cp.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1:2]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(2, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "poisson_rW_cp2W"),
error = function(e) e)
})
save(res_list, file = "../../../results_public/2_evaluation/bavaria/poiss_rW_cp_2w_synthetic.RData")
res_list
res_list[[2]]
res_list[[1]]
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../../models/negBinom_rWalk_rWalk_wd.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1:2]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(2, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_rW_wd"),
error = function(e) e)
})
save(res_list, file = "../../../results_public/2_evaluation/bavaria/negBinom_rW_rW_wd_synthetic.RData")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_rWalk_wd.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1:2]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(2, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_rW_wd"),
error = function(e) e)
})
save(res_list, file = "../../../results_public/2_evaluation/bavaria/negBinom_rW_rW_wd_synthetic.RData")
res_list[[1]]
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod_negBinom_rW_rW = readRDS("../stan_models/negBinom_rWalk_rWalk.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1:2]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(2, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod_negBinom_rW_rW,
mod_name = "negBinom_rW_rW"),
error = function(e) e)
})
save(res_list, file = "../../../results_public/2_evaluation/bavaria/negBinom_rW_rW_synthetic.RData")
res_list
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_bavaria_persspec_synth.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp_wExt_Delay.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1:2]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(2, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
# Apply over dates to perform nowcasting based on data available until 'now'
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cp2W_wd"),
error = function(e) e)
})
save(res_list, file = "../../../results_public/2_evaluation/bavaria/negBinom_rW_cp_2w_wd_synthetic.RData")
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_synthetic_data")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_mod_synthetic.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(workers = 1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cptrue"),
error = function(e) e)
})
# save(res_list, file = "../../../results_public/2_evaluation/synthetic_data/negBinom_rW_cp_true.RData")
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_synthetic_data")
setwd("~/Documents/nc_covid19_bavaria/code_public/2_evaluation/est_synthetic_data")
library(Rcpp)
library(surveillance)
library(rstan)
library(lubridate)
library(tidyverse)
library(nleqslv)
library(scoringRules)
library(R0)
library(future)
library(future.apply)
# Load data
load("../../../data_public/evaluation/dat_mod_synthetic.RData")
# Load model
mod = readRDS("../stan_models/negBinom_rWalk_cp.rds")
# Load functions to estimate nowcast
source("../eval_fun.R")
# Define dates for which to estimate nowcast
eval_dates = seq(ymd("2020-02-24") + 22, ymd("2020-06-30"), by = 1)
# Restrict to fewer dates for faster computation
eval_dates = eval_dates[1]
# Setup cluster to perform estimation
# Library Path
libs <- .libPaths()[1]
libs_cmd <- sprintf(".libPaths(c(%s))", paste(sprintf('"%s"', libs), collapse = ", "))
# Define number of workers
# Note that each call to estimate_nowcast starts four parallel chains of MCMC sampling
# (Available number of cores has to be 4 times the number of workers in cluster)
cl <- future::makeClusterPSOCK(workers = 1, rscript_args = c("-e", shQuote(libs_cmd)))
plan(cluster, workers = cl)
res_list = future_lapply(sample(eval_dates), FUN = function(x) {
print(paste0("Start nowcast: ",x))
tryCatch(estimate_nowcast(now=x,
data = dat_mod,
begin_date = ymd("2020-02-24"),
D=21,
predLag = 2,
model = mod,
mod_name = "negBinom_rW_cptrue"),
error = function(e) e)
})
# save(res_list, file = "../../../results_public/2_evaluation/synthetic_data/negBinom_rW_cp_true.RData")
res_list
